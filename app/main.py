# Implements an OAuth1 wrapper for an python app
# Resources:
# https://blog.authlib.org/2020/fastapi-twitter-login
#
#
#

import os
import re
import fastapi
import panel as pn
from bokeh.embed import server_document
from bokeh.util.token import generate_session_id
from fastapi import FastAPI, Request
from fastapi.templating import Jinja2Templates
from urllib.parse import urljoin

import json
from pprint import pprint
import starlette
#from fastapi import FastAPI
from starlette.config import Config
#from starlette.requests import Request
#from starlette.middleware.sessions import SessionMiddleware
from starlette_authlib.middleware import AuthlibMiddleware as SessionMiddleware
from starlette.responses import HTMLResponse, RedirectResponse
from authlib.integrations.starlette_client import OAuth, OAuthError
from authlib.jose import JsonWebEncryption, jwt

from mwoauth import ConsumerToken, Handshaker, AccessToken

#from sliders.pn_app import createApp
#from app.osw_app.pn_dashboard import createApp
from apps import serving, titles

from osw.auth import CredentialManager
import osw.model.entity as model
from osw.core import OSW
from osw.wtsite import WtSite

print("START")
app_session_secret = os.environ.get('APP_SESSION_SECRET')
app = FastAPI()
app.add_middleware(SessionMiddleware, secret_key=app_session_secret)

oauth = OAuth()

host = os.environ.get('APP_HOST')
port = int(os.environ.get('APP_PORT'))
domain = os.environ.get('APP_DOMAIN')
if "://" in domain:
    domain = domain.split("://")[1]
    
internal_host = 'localhost'
internal_port = 5001
osw_server = os.environ.get('OSW_SERVER')

key = os.environ.get('OAUTH_CLIENT_ID')
secret = os.environ.get('OAUTH_CLIENT_SECRET')
# 128 bit key to sign the JWT
jwt_key = bytes.fromhex(os.environ.get('APP_JWT_KEY'))
# 128 bit key to encrypt the JWT as JWE
jwe_key = bytes.fromhex(os.environ.get('APP_JWE_KEY'))

oauth.register(
    name='mediawiki',
    #api_base_url='/wiki/Special:OAuth/initiate',
    request_token_url=osw_server+'/wiki/Special:OAuth/initiate',
    access_token_url=osw_server+'/wiki/Special:OAuth/token',
    authorize_url=osw_server+'/wiki/Special:OAuth/authorize',
    client_id =key,
    client_secret=secret,
)

consumer_token = ConsumerToken(  key = key, secret=secret)
# Construct handshaker with wiki URI and consumer
handshaker = Handshaker(osw_server+"/w/index.php",
                        consumer_token)

templates = Jinja2Templates(directory="/app/templates")

def get_jwe_from_json(json_payload) -> str:
    
    # create the JWT
    jwt_header = {'alg': 'HS256'}
    jwt_payload = json_payload
    jwt_encoded = jwt.encode(jwt_header, jwt_payload, jwt_key)

    # create the JWE
    jwe = JsonWebEncryption()
    jwe_header = {'alg': 'A128KW', 'enc': 'A128CBC-HS256'}
    jwe_payload = jwt_encoded
    jwe_encrypted = jwe.serialize_compact(jwe_header, jwe_payload, jwe_key)

    return jwe_encrypted.decode('utf-8')

def get_json_from_jwe(jwe_encrypted: str) -> dict:
    jwe_encrypted = jwe_encrypted.encode('utf-8')
    # decrypt the JWE
    jwe = JsonWebEncryption()
    data = jwe.deserialize_compact(jwe_encrypted, jwe_key)
    jwe_header = data['header']
    payload = data['payload']

    # decode the JWT
    claims = jwt.decode(payload, jwt_key)
    return claims

def get_osw(osw_token) -> OSW:
    cm = CredentialManager()

    cm.add_credential(cred=CredentialManager.OAuth1Credential(
        iri=osw_server,
        consumer_token= key,
        consumer_secret= secret,
        access_token= osw_token['oauth_token'],
        access_secret= osw_token['oauth_token_secret']
    ))
    wtsite = WtSite(WtSite.WtSiteConfig(iri=osw_server, cred_mngr=cm))
    osw = OSW(site=wtsite)
    return osw

@app.get('/')
async def homepage(request: Request):
    pprint( request.session)
    encrypted_token = request.session.get('osw_token')
    if encrypted_token:
        token = get_json_from_jwe(encrypted_token)
        print("USER GET")
        osw = get_osw(token)
        pn.state.cache['osw'] = osw
        pn.state.cache['osw_user'] = token["username"]
        data = json.dumps(token["username"])
  
        url = f"https://{domain}/panel/app"
        # generate sessions here, otherwise fastapi auth could be bypassed
        headers = {"bokeh-session-id": generate_session_id(app_session_secret, signed=True)}
        script = server_document(url=url, arguments=dict(request.query_params), headers=headers)
        return templates.TemplateResponse("base.html", {"request": request, "script": script, "data": data})

    return HTMLResponse('<a href="/login">login</a>')

pn.serve(
    #{'/panel/app': createApp},
    serving,
    port=internal_port, 
        address=host,
        show=False,
        # sessions are generated by fastapi => no bypass possible
        sign_sessions=True,
        secret_key=app_session_secret,
        generate_session_ids=False,
        )


@app.get('/login')
async def login(request: Request):
    redirect_uri = f"https://{domain}/auth"
    print("Redirect url", redirect_uri)
    return await oauth.mediawiki.authorize_redirect(request, redirect_uri)


@app.get('/auth')
async def auth(request: Request):
    try:
        token = await oauth.mediawiki.authorize_access_token(request)
        userinfo = handshaker.identify(AccessToken( token["oauth_token"], token["oauth_token_secret"]))
        token["username"] = userinfo['username']
    except OAuthError as error:
        pprint(error)
        return HTMLResponse(f'<h1>{error.error}</h1>')
    pprint(token)
    #pprint( request.session)

    # OAuth2 / OICD
    user = userinfo #token.get('userinfo')
    if token:
        print("USER SET")
        # in general, large objects seem to fail to be stored in the session
        # therefore, we store only token, secret and username (all encrypted)
        # but maybe we should just use encrypted cookies here: https://securecookies.thearchitector.dev/securecookies.html
        # see also http://cryto.net/%7Ejoepie91/blog/2016/06/13/stop-using-jwt-for-sessions/
        # http://cryto.net/%7Ejoepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/

        request.session['osw_token'] = get_jwe_from_json(token)
        pprint( request.session)

    return RedirectResponse(url='/')


@app.get('/logout')
async def logout(request: Request):
    request.session.pop('osw_token', None)
    return RedirectResponse(url='/')

print("INIT", host, port)
if __name__ == '__main__':
    print("MAIN")
    import uvicorn
    uvicorn.run(app, host=host, port=port)